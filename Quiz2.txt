 а) Во взвешенном неориентированном графе G = (V, E, w), поиск в ширину из вершины s находит кратчайшие пути до каждой
    вершины из s за время O(V + E).
    True, так как нам надо посетить каждое ребро и каждую вершину 1 раз.
----------------------------------------------------------------------
 б) Во взвешенном неориентированном дереве G = (V, E, w), поиск в ширину из вершины s находит кратчайшие пути до каждой
    вершины из s за время O(V + E).
    True, так как дерево - это связный ациклический граф. 
    Если бинарное дерево сбалансировано, - E = O(V), следовательно поиск может быть O(log(V))
----------------------------------------------------------------------
 в) Во взвешенном неориентированном дереве G = (V, E, w), поиск в глубину из вершины s находит кратчайшие пути до каждой
    вершины из s за время O(V + E).
    True, все равно посещаем каждую вершину и ребро, только в другом порядке. Не преимуществ сбалансированной структуры         дерева.
----------------------------------------------------------------------
 г) В графе, представляющем задания и их связи ((а, б) значит, что а должно произойти перед б), поиск в ширину находит
    задания в правильном порядке их выполнения
    False, если граф (а,c)(a,б)(а,д), то поиск в ширину вернет (a,c,d,b).
----------------------------------------------------------------------
 д) Алгоритм Дейкстры для нахождения кратчайшего пути может "облегчить/расслабить" более чем одну вершину в графе с циклами
   True. Релаксация - уменьшение дистанции между вершинами. В случае Дейкстеры, это происходит для всех вершин.
----------------------------------------------------------------------
 е) Во взвешенном ориентированном графе G = (V, E, w) с истоком s ∈ V, если G имеет цикл с отрицательным весом, алгоритм
    Беллмана-Форда обязательно вычислит неверный результат для δ(s, v).
    True, именно так алгоритм Беллмана-Форда находит циклы с отрицательным весом - вычисляя неверный результат.
    Неверный результат - значение для δ(s, v) изменится по сравнению с предыдущим шагом после всех операций.
----------------------------------------------------------------------
 ж) Во взвешенном ориентированном графе G = (V, E, w) не содержащем нулевых и положительных циклов, Беллман-Форд может найти
    самый длинный (максимальный по весу) путь из вершины s в вершину t.
    True. Проблема максимального по весу пути из вершины s в вершину t - проблема минимального пути в этом случае. Возьмем все     веса по модулю и найдем минимальный путь.
----------------------------------------------------------------------
 з) Во взвешенном ориентированном графе G = (V, E, w) содержащем цикл с отрицательным весом, Беллман-Форд найдет кратчайший
    путь из вершины s в вершину t, не содержащий циклов.
    False. В общем случае - нет, в частном случае(если цикл не достижим из s) - true.
----------------------------------------------------------------------
 и) Имея на входе взвешенный ориентированный граф G = (V, E, w) и кратчайший путь p из s в t, если мы удвоим вес каждого ребра
    чтобы получился граф G0 = (V, E, w0), то путь p будет также кратчайшим путем в G0
    True, шкалирование графа не изменит кратчайший путь.
----------------------------------------------------------------------
 к) Полиномиальное(O(n^c)) - хорошо. Экспоненциальное(O(c^n)) - плохо
    True, при увеличении n, экспоненциальная сложность растет гораздо быстрее полиномиального.
----------------------------------------------------------------------
 л) Любое несбалансированное дерево из n элементов можно сбалансировать при помощи O(log n) поворотов
    False, балансировка несбалансированого дерева в худшем случае, это тоже самое, что стоить дерево с самого начала, что 
    обычно - O(n*log(n))
----------------------------------------------------------------------
 м) Если в AVL дереве мы будем хранить в каждой вершине размер поддерева, то мы сможем для двух ключей x и y найти
    количество ключей, находящихся между x и y
     						                          R
                                                    /  \
                                                  /      \
                                                /          \
                                              /              \
                                            21             22
                                          /  \              /  \
                                        /      \          /      \
                                      X       Y1       Y2         Y3
                                    / \       / \     / \        / \
    True. Обойти дерево надо будет в любом случае, использование поддеревьев поможет, время будет O(log(n)).
    Пусть X<Y. Найдем общий узел R, посчитаем его, вернемся к X, для каждого узла - если значение > X считаем его + размер         правого поддерева. Тоже самое для Y.
----------------------------------------------------------------------
 н) Для динамического программирования вычисление при помощи восходящего подхода асимптотически быстрее, чем вычисление при
    помощи рекурсии и мемоизации
    False, так рекурсия + мемоизация решают проблемы по мере их поступления, а восходящий подход решает все подзадачи и       
    возможно решит больше чем надо на самом деле.
----------------------------------------------------------------------
 о) Время работы алгоритма динамического программирования всегда O(P) где P - количество подзадач
    True, так как с динамическим программированием каждая задача оценивается один раз.
----------------------------------------------------------------------
 п) Если рекуррентное соотношение имеет циклическую зависимость, такое рекуррентное соотношение невозможно использовать
    для решения задачи динамического программирования
    True, циклическая зависимость не разрешает создавать решения подзадач, которые будут запомнены и переиспользованы.
----------------------------------------------------------------------
 р) Любая задача в NP может быть решена за экспоненциальное время
    True. Перечислив все возможные решения и проверив их в полиноминальное время.
----------------------------------------------------------------------
 с) Если задача X может быть сведена к известной NP-сложной проблеме, то X должна быть также NP-сложной
    True. Определение NP-сложной задачи: задача H - NP-сложная, если каждая задача X в NP может быть в полиноминальное время     сведена к H. X - NP, что является подмножетсвом NP-сложной.
----------------------------------------------------------------------
 т) Если P == NP, то NP == NP-полная
    True
    NP-полное подмножество NP. Если P==NP, значит NP-полное подмножетсво P, что значит каждая NP-полная задача может быть          решена и проверена за полиноминальное время, что значит NP = NP-полная.
