Решение #3
a)функция init(N,K,P):
  -комбинации_Продуктов = Биноминальный коэфициент(N,K)//создаем всевозможные комбинации цен продуктов размеров К
  -Для каждой комбинации_Продуктов:
    -считаем сумму комбинации
    -кладем в Хэш-таблицу, где ключ - сумма комбинации, значение - комбинация_Продуктов
    
б)функция PWH-Contest(N,S,K,P):
  -если K%2 == 0:
    -выполняем пока не найдем, комбинацию товаров размера K, чья сумма будет равна S:
      -создаем комбинацию продуктов длинной K/2, вычисляем ее сумму(S1)
      -если в нашей хэш-таблице есть Ключ равный S2 = S - S1, то:
        -копируем элементы из Хэш-таблицы[S2] в Хэш-таблицу[S1]
        -возвращаем их индексы
        -завершаем цикл
      -если нет, добавляем в нашу Хэш-таблицу эту комбинацию с ключем равной ее сумме элементов, продолжаем цикл
  -иначе:
    -выполняем пока не найдем, комбинацию товаров размера K, чья сумма будет равна S:
      -создаем комбинацию продуктов длинной (K-1)/2, вычисляем ее сумму(S1)
      -если в нашей хэш-таблице есть Ключ равный S2 = S - S1, то:
        -копируем элементы из Хэш-таблицы[S2] в Хэш-таблицу[S1]
        -возвращаем их индексы
        -завершаем цикл
      -если нет:
        -создаем комбинацию длинной (K + 1)/2, вычисляем ее сумму
        -если такой суммы нет в Хэш-таблице:
          -добавяем в Хэш-таблицу с ключом суммой и комбинацией в виде значения
        
в)Анализ б)
Размер одной комбинации ~ O(K/2). Мы в ран-тайме создаем структуру с О(N^(K/2)) элементами и при создании новой комбинации, мы проверяем
можем ли мы достичь цель = S. Поэтому сложность алгоритма(в плане времени и места) = О(N^(K/2)).
Итоговая сложность алгритма = O(K*N^(K/2))(умножение на K, так как мы копируем еще элементы из старой комбинации(которая есть уже в хэш-таблице)
в новую.

Решение #4(Python)

def diff(a):
    ma = [0 for i in range(len(a))]
    mb = [0 for i in range(len(a))]
    ma[0] = a[0]
    for i in range(1, len(ma)):
        ma[i] = min(a[i], ma[i - 1])
    last = len(a) - 1
    mb[last] = a[last]
    for j in range(last - 1,-1,-1):
        mb[j] = max(mb[j+1], a[j])
    i = 0
    j = 0
    maxdiff = -1
    while True:
        if ma[i] < mb[j]:
            maxdiff = max(maxdiff, j - i)
            j += 1
            if j >= len(a):
                break
        else:
            i += 1
            if i >= len(a):
                break
    return maxdiff